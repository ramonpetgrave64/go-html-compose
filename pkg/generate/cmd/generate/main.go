package main

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"os"
	"strings"
)

func main() {
	if err := generateAttributes(); err != nil {
		panic(err)
	}
}

type attribute struct {
	name        string
	tags        string
	description string
	isBoolean   bool
	deprecated  bool
}

func generateAttributes() error {
	file, err := os.Open("attributes.csv")
	if err != nil {
		return err
	}
	data := csv.NewReader(file)
	records, err := data.ReadAll()
	if err != nil {
		return err
	}
	attributes := []*attribute{}
	for _, record := range records {
		name := record[0]
		deprecated := strings.Contains(name, "Deprecated")
		cleanName := strings.SplitN(name, " ", 2)[0]
		attr := &attribute{
			name:        cleanName,
			tags:        record[1],
			description: record[2],
			deprecated:  deprecated,
			isBoolean:   isBooleanAttribute(record[2]),
		}
		attributes = append(attributes, attr)
	}
	var buf bytes.Buffer
	buf.Write([]byte(`// Code generated by "go run -C ../generate ./cmd/generate/"; DO NOT EDIT.
	
package attr

`))
	for _, attr := range attributes {
		funcName := namePascalCase(attr.name)
		attrFunc := "Attr"
		if attr.isBoolean {
			attrFunc = "BooleanAttr"
		}
		deprecationNotice := ""
		if attr.deprecated {
			deprecationNotice = fmt.Sprintf("\n// Deprecated: %s is deprecated.\n", funcName)
		}

		_, err := fmt.Fprintf(
			&buf,
			`// %s:
// Description: %s
// Tags: %s%s
func %s(value string) *AttributeStruct {
	return %s("%s", &value)
}

`,
			funcName, strings.ReplaceAll(attr.description, "\n", "\n// "), attr.tags, deprecationNotice, funcName, attrFunc, attr.name,
		)
		if err != nil {
			return nil
		}
	}
	s := buf.String()
	print(s)
	return nil
}

func namePascalCase(name string) string {
	pascalName := ""
	for _, part := range strings.Split(name, "-") {
		pascalName += strings.ToUpper(part[0:1]) + part[1:]
	}
	return pascalName
}

func isBooleanAttribute(description string) bool {
	subs := []string{"boolean", "whether"}
	for _, sub := range subs {
		if strings.Contains(description, sub) {
			return true
		}
	}
	return false
}

// func Action(value string) *AttributeStruct {
// 	return Attr("action", &value)
// }

// func generateAttributes() error {
// 	file, err := downloadFile(attirbutesURL, attributesFilePath)
// 	if err != nil {
// 		return err
// 	}
// 	doc, err := html.Parse(file)
// 	if err != nil {
// 		return err
// 	}
// 	// fc, err := io.ReadAll(file)
// 	// if err != nil {
// 	// 	panic(err)
// 	// }
// 	// slog.Info(string(fc))
// 	// slog.Info("gen")
// 	tbody := digDescendantData(doc, "body", "table", "tbody")
// 	// slog.Info(tbody.Data)
// 	// for n := range tbody.Descendants() {
// 	// 	slog.Info(n.Data)
// 	// }
// 	// for tr := range digData(tbody, )
// 	// attributes := []*attribute{}
// 	// slog.Info(tbody.Data)
// 	for tr := range tbody.ChildNodes() {
// 		slog.Info(tr.Data)
// 		if tr.Data != "tr" {
// 			continue
// 		}
// 		a := digDescendantData(tr, "td", "code", "a")
// 		slog.Info(a.Data)
// 		// for td := range tr.ChildNodes() {
// 		// 	if td.Data != "td" {
// 		// 		continue
// 		// 	}
// 		// 	a := digDescendantData(td, "code", "a")
// 		// 	slog.Info(a.Data)
// 		// }
// 	}

// 	return nil
// }

// func digDescendantData(node *html.Node, datum ...string) *html.Node {
// 	child := node
// 	for i, d := range datum {
// 		slog.Info(fmt.Sprintf("%d, %s, %s", i, d, node.Data))
// 		found := false
// 		for n := range child.Descendants() {
// 			// slog.Error(n.Data)
// 			if n.Data == d {
// 				child = n
// 				slog.Info("found")
// 				found = true
// 				break
// 			}
// 		}
// 		if !found {
// 			panic(fmt.Errorf("child not found: %d %s", i, d))
// 		}
// 	}
// 	slog.Error(child.Data)
// 	return child
// }

// func downloadFile(url, output string) (*os.File, error) {
// 	resp, err := http.Get(url)
// 	if err != nil {
// 		return nil, err
// 	}
// 	defer resp.Body.Close()
// 	if resp.StatusCode != http.StatusOK {
// 		return nil, fmt.Errorf("bad status: %s", resp.Status)
// 	}
// 	file, err := os.Create(output)
// 	if err != nil {
// 		return nil, err
// 	}
// 	if _, err = io.Copy(file, resp.Body); err != nil {
// 		return nil, err
// 	}
// 	if err := file.Close(); err != nil {
// 		return nil, err
// 	}
// 	return os.Open(output)
// }
